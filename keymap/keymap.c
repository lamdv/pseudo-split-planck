#include QMK_KEYBOARD_H
// Left-hand home row mods
#define HOME_A LSFT_T(KC_A)
#define HOME_S LCTL_T(KC_S)
#define HOME_D LGUI_T(KC_D)
#define HOME_F LALT_T(KC_F)

// Right-hand home row mods
#define HOME_J LALT_T(KC_J)
#define HOME_K RGUI_T(KC_K)
#define HOME_L RCTL_T(KC_L)
#define HOME_P RSFT_T(KC_P)


enum {
    TD_SPC_TAB,
    TD_Q_ESC,
    TD_LCURLY,
    TD_RCURLY,
    TD_HOME,
    TD_END,
    TD_QUOTE_GRAVE
};

// Tap Dance definitions
tap_dance_action_t tap_dance_actions[] = {
    // Tap once for Escape, twice for Caps Lock
    [TD_SPC_TAB] = ACTION_TAP_DANCE_DOUBLE(KC_SPC, KC_TAB),
    [TD_Q_ESC] = ACTION_TAP_DANCE_DOUBLE(KC_Q, KC_ESC),
    [TD_QUOTE_GRAVE] = ACTION_TAP_DANCE_DOUBLE(KC_QUOT, KC_GRV),
    [TD_LCURLY] = ACTION_TAP_DANCE_DOUBLE(KC_LBRC, KC_LCBR),
    [TD_RCURLY] = ACTION_TAP_DANCE_DOUBLE(KC_RBRC, KC_RCBR),
    [TD_HOME] = ACTION_TAP_DANCE_DOUBLE(KC_HOME, KC_PGUP),
    [TD_END] = ACTION_TAP_DANCE_DOUBLE(KC_END, KC_PGDN),
    
    }; 


const rgblight_segment_t PROGMEM my_layer1_layer[] = RGBLIGHT_LAYER_SEGMENTS(
    {0, 9, HSV_CYAN}
);
// Light LEDs 11 & 12 in purple when keyboard layer 2 is active
const rgblight_segment_t PROGMEM my_layer2_layer[] = RGBLIGHT_LAYER_SEGMENTS(
    {0, 9, HSV_GREEN}
);

const rgblight_segment_t* const PROGMEM my_rgb_layers[] = RGBLIGHT_LAYERS_LIST(
    my_layer1_layer,
    my_layer2_layer
);

void keyboard_post_init_user(void) {
    // Enable the LED layers
    rgblight_layers = my_rgb_layers;
}

uint16_t get_tapping_term(uint16_t keycode, keyrecord_t *record) {

            return 250;
}
/* THIS FILE WAS GENERATED!
 *
 * This file was generated by qmk json2c. You may or may not want to
 * edit it directly.
 */

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
	[0] = LAYOUT_planck_2x2u(
        TD(TD_Q_ESC),        KC_W,  KC_E,    KC_R,       KC_T,        KC_NO,KC_NO,  KC_Y,     KC_U,     KC_I,    KC_O,    KC_SLSH, 
                LT(1,KC_A),        KC_S,  HOME_D,  HOME_F,     KC_G,        KC_NO,KC_NO,  KC_H,    HOME_J,   HOME_K ,  KC_L,    KC_P, 
                KC_Z, KC_X,  KC_C,    KC_V,       KC_B,        KC_NO,KC_NO,  KC_N,     KC_M,    KC_COMM, KC_DOT, LT(1, KC_SCLN), 
        KC_NO, KC_NO, KC_NO,        OSM(MOD_LSFT),     TD(TD_SPC_TAB),                   OSL(3), OSM(MOD_RCTL),
        KC_NO, KC_NO, KC_NO),
	[1] = LAYOUT_planck_2x2u(
        RGB_TOG,    TD(TD_HOME), KC_UP,      TD(TD_END), RGB_RMOD, KC_NO,KC_NO,    CW_TOGG   , KC_WH_U, KC_MS_U, KC_BTN3, KC_DEL, 
        LCTL(KC_Y), KC_LEFT,     KC_DOWN,    KC_RGHT,    RGB_HUI,  KC_NO,KC_NO,    KC_ACL2   , KC_MS_L, KC_MS_D, KC_MS_R, KC_ENT, 
        KC_NO, LCTL(KC_X),  LCTL(KC_C),     LCTL(KC_V),  RGB_HUD,  KC_NO,KC_NO,     KC_NO    , KC_WH_D, KC_WH_L, KC_WH_R, KC_TRNS,
        KC_NO,KC_NO,KC_NO ,           KC_LALT,  TO(0),                      KC_BTN1   , KC_BTN2,
        KC_NO, KC_NO, KC_NO),
	[2] = LAYOUT_planck_2x2u(
        KC_ESC,KC_VOLD, KC_VOLU, KC_MPLY,      KC_UNDS, KC_NO,KC_NO, KC_7,  KC_8,  KC_9, KC_0,    KC_BSPC, 
        KC_TAB, KC_LBRC,KC_LCBR, KC_QUOT,      KC_PLUS, KC_NO,KC_NO, KC_4,  KC_5,  KC_6, KC_MINS, KC_ENT,
        KC_DEL, KC_RBRC,KC_RCBR, KC_SLSH,      KC_BSLS, KC_NO,KC_NO, KC_1,  KC_2,  KC_3, KC_EQL,  TO(1),
        KC_NO , KC_NO, KC_NO, OSM(MOD_LSFT),    TO(0),              TO(3), KC_RCTL,
        KC_NO, KC_NO, KC_NO),
	[3] = LAYOUT_planck_2x2u(
        KC_ESC, KC_AT  , KC_HASH, KC_DLR,       KC_PERC, KC_NO,KC_NO, KC_CIRC,  KC_AMPR,  KC_ASTR, KC_BSLS, KC_BSPC, 
        KC_TAB, KC_EXLM, KC_GRAVE, KC_DQT, KC_QUOT, KC_NO,KC_NO, KC_LBRC,KC_RBRC ,  KC_LPRN, KC_RPRN, KC_ENT,
        KC_DEL, KC_UNDS, KC_MINUS, KC_PLUS, KC_EQUAL,  KC_NO,KC_NO, KC_LCBR,KC_RCBR ,   KC_LT, KC_GT,  TO(1),
        KC_NO , KC_NO, KC_NO,  KC_LALT ,  TO(0),                     TO(2), KC_RCTL,
        KC_NO, KC_NO, KC_NO)
};

#if defined(ENCODER_ENABLE) && defined(ENCODER_MAP_ENABLE)
const uint16_t PROGMEM encoder_map[][NUM_ENCODERS][2] = {

};
#endif // defined(ENCODER_ENABLE) && defined(ENCODER_MAP_ENABLE)
