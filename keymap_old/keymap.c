#include QMK_KEYBOARD_H
#include "print.h"

// Left-hand home row mods
#define HOME_A LSFT_T(KC_A)
#define HOME_S LCTL_T(KC_S)
#define HOME_D LGUI_T(KC_D)
#define HOME_F LALT_T(KC_F)

// Right-hand home row mods
#define HOME_J LALT_T(KC_J)
#define HOME_K RGUI_T(KC_K)
#define HOME_L RCTL_T(KC_L)
#define HOME_P RSFT_T(KC_P)

typedef struct {
    uint16_t tap;
    uint16_t hold;
    uint16_t held;
} tap_dance_tap_hold_t;


void tap_dance_tap_hold_finished(tap_dance_state_t *state, void *user_data) {
    tap_dance_tap_hold_t *tap_hold = (tap_dance_tap_hold_t *)user_data;

    if (state->pressed) {
        if (state->count == 1
#ifndef PERMISSIVE_HOLD
            && !state->interrupted
#endif
        ) {
            register_code16(tap_hold->hold);
            tap_hold->held = tap_hold->hold;
        } else {
            register_code16(tap_hold->tap);
            tap_hold->held = tap_hold->tap;
        }
    }
}

void tap_dance_tap_hold_reset(tap_dance_state_t *state, void *user_data) {
    tap_dance_tap_hold_t *tap_hold = (tap_dance_tap_hold_t *)user_data;

    if (tap_hold->held) {
        unregister_code16(tap_hold->held);
        tap_hold->held = 0;
    }
}


#define ACTION_TAP_DANCE_TAP_HOLD(tap, hold) \
    { .fn = {NULL, tap_dance_tap_hold_finished, tap_dance_tap_hold_reset}, .user_data = (void *)&((tap_dance_tap_hold_t){tap, hold, 0}), }

enum {
    TD_SPC_TAB,
    TD_Q_ESC,
    TD_LCURLY,
    TD_RCURLY,
    TD_HOME,
    TD_END,
    TD_QUOTE_GRAVE
};

enum planck_layers {
    _QWERTY,
    _NUMBER,
    _SYMBOL,
    _NAV,
    _ALT_NAV,
};

// Tap Dance definitions
tap_dance_action_t tap_dance_actions[] = {
    // Tap once for Escape, twice for Caps Lock
    [TD_SPC_TAB] = ACTION_TAP_DANCE_DOUBLE(KC_SPC, KC_TAB),
    [TD_Q_ESC] = ACTION_TAP_DANCE_DOUBLE(KC_Q, KC_ESC),
    [TD_QUOTE_GRAVE] = ACTION_TAP_DANCE_DOUBLE(KC_QUOT, KC_GRV),
    [TD_LCURLY] = ACTION_TAP_DANCE_DOUBLE(KC_LBRC, KC_LCBR),
    [TD_RCURLY] = ACTION_TAP_DANCE_DOUBLE(KC_RBRC, KC_RCBR),
    [TD_HOME] = ACTION_TAP_DANCE_TAP_HOLD(KC_PGUP, KC_HOME),
    [TD_END] = ACTION_TAP_DANCE_TAP_HOLD(KC_PGDN, KC_END),
    
    }; 



bool process_record_user(uint16_t keycode, keyrecord_t *record) {
    tap_dance_action_t *action;

    switch (keycode) {
        case TD(TD_HOME):
        case TD(TD_END):  // list all tap dance keycodes with tap-hold configurations
            action = &tap_dance_actions[TD_INDEX(keycode)];
            if (!record->event.pressed && action->state.count && !action->state.finished) {
                tap_dance_tap_hold_t *tap_hold = (tap_dance_tap_hold_t *)action->user_data;
                tap_code16(tap_hold->tap);
            }
            return true;
        case TO(_QWERTY):
            if (record->event.pressed) {
                cancel_all_one_shots();
                return true;
            }
        default:
            return true;
    }

}

uint16_t get_tapping_term(uint16_t keycode, keyrecord_t *record) {
    switch (keycode) {
        case TD(TD_HOME):
        case TD(TD_END):
            return 500;
        default:
            return 250;
    }
}
/* THIS FILE WAS GENERATED!
 *
 * This file was generated by qmk json2c. You may or may not want to
 * edit it directly.
 */

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
	[_QWERTY] = LAYOUT_planck_2x2u(
        TD(TD_Q_ESC),  KC_W,  KC_E,    KC_R,        KC_T,           KC_NO,KC_NO,  KC_Y,       KC_U,     KC_I,    KC_O,    KC_SLSH, 
        LT(_NAV,KC_A), KC_S,  HOME_D,  HOME_F,      KC_G,           KC_NO,KC_NO,  KC_H,      HOME_J,   HOME_K ,  KC_L,    KC_P, 
        KC_Z,          KC_X,  KC_C,    KC_V,        KC_B,           KC_NO,KC_NO,  KC_N,       KC_M,    KC_COMM, KC_DOT, LT(_NAV, KC_SCLN), 
        KC_NO, KC_NO, KC_NO,        OSM(MOD_LSFT),  TD(TD_SPC_TAB),           OSL(_SYMBOL), OSM(MOD_RCTL),
        KC_NO, KC_NO, KC_NO),
	[_NAV] = LAYOUT_planck_2x2u(
        KC_ESC,        KC_MUTE    , KC_VOLD,    KC_VOLU,    TO(_ALT_NAV), KC_NO,KC_NO,LCTL(KC_C), TD(TD_END), TD(TD_HOME), LCTL(KC_V), KC_DEL, 
        OSM(MOD_LALT), KC_LEFT    , KC_DOWN,    KC_UP  ,    KC_RGHT,  KC_NO,KC_NO,    KC_MS_L   , KC_MS_D,    KC_MS_U,     KC_MS_R, KC_ENT ,
        OSM(MOD_LCTL), KC_HOME    , KC_PGDN,    KC_PGUP,    KC_END ,  KC_NO,KC_NO,    KC_WH_L   , KC_WH_D,    KC_WH_U,     KC_WH_R, KC_BTN3,
        KC_NO,KC_NO,KC_NO ,                  OSM(MOD_LSFT), TO(_QWERTY),              KC_BTN1   , KC_BTN2,
        KC_NO, KC_NO, KC_NO),
	[_ALT_NAV] = LAYOUT_planck_2x2u(
        KC_ESC,        TD(TD_HOME), KC_UP,      TD(TD_END), TO(_NAV),  KC_NO,KC_NO,    LCTL(KC_C), KC_PGDN, KC_PGUP, LCTL(KC_V), KC_DEL, 
        OSM(MOD_LALT), KC_LEFT,     KC_DOWN,    KC_RGHT,    KC_VOLU,    KC_NO,KC_NO,    KC_MS_L   , KC_MS_D, KC_MS_U, KC_MS_R, KC_ENT ,
        OSM(MOD_LCTL), KC_MUTE    , KC_VOLD,    KC_VOLU,    KC_VOLD,    KC_NO,KC_NO,    KC_WH_L   , KC_WH_D, KC_WH_U, KC_WH_R, KC_BTN3,
        KC_NO,KC_NO,KC_NO ,                  OSM(MOD_LSFT), TO(_QWERTY),              KC_BTN1   , KC_BTN2,
        KC_NO, KC_NO, KC_NO),
	[_NUMBER] = LAYOUT_planck_2x2u(
        KC_ESC, KC_F1, KC_F2, KC_F3,  KC_F4,  KC_NO,KC_NO,     KC_7,    KC_8,  KC_9, KC_0,    KC_BSPC, 
        KC_TAB, KC_F5,KC_F6 , KC_F7,  KC_F8,  KC_NO,KC_NO,     KC_4,    KC_5,  KC_6, KC_COMM, KC_ENT,
        KC_DEL, KC_F9,KC_F10, KC_F11, KC_F12, KC_NO,KC_NO,     KC_1,    KC_2,  KC_3, KC_DOT,  TO(_NAV),
        KC_NO , KC_NO, KC_NO, KC_LALT,TO(_QWERTY),         TO(_SYMBOL), KC_RCTL,
        KC_NO, KC_NO, KC_NO),
	[_SYMBOL] = LAYOUT_planck_2x2u(
        KC_ESC, KC_AT  , KC_HASH, KC_DLR,       KC_PERC, KC_NO,KC_NO, KC_CIRC,  KC_AMPR,  KC_ASTR, KC_BSLS, KC_BSPC, 
        KC_TAB, KC_EXLM, KC_GRAVE, KC_DQT, KC_QUOT, KC_NO,KC_NO, KC_LBRC,KC_RBRC ,  KC_LPRN, KC_RPRN, KC_ENT,
        KC_DEL, KC_UNDS, KC_MINUS, KC_PLUS, KC_EQUAL,  KC_NO,KC_NO, KC_LCBR,KC_RCBR ,   KC_LT, KC_GT, TO(_NAV),
        KC_NO , KC_NO, KC_NO,  KC_LALT ,  TO(_QWERTY),              TO(_NUMBER), KC_RCTL,
        KC_NO, KC_NO, KC_NO)
};

#if defined(ENCODER_ENABLE) && defined(ENCODER_MAP_ENABLE)
const uint16_t PROGMEM encoder_map[][NUM_ENCODERS][2] = {

};
#endif // defined(ENCODER_ENABLE) && defined(ENCODER_MAP_ENABLE)

const rgblight_segment_t PROGMEM _QWERTY_layer[] = RGBLIGHT_LAYER_SEGMENTS(
    {0, 9, HSV_BLUE}
);
const rgblight_segment_t PROGMEM _NUMBER_layer[] = RGBLIGHT_LAYER_SEGMENTS(
    {0, 9, HSV_GREEN}
);
const rgblight_segment_t PROGMEM _SYMBOL_layer[] = RGBLIGHT_LAYER_SEGMENTS(
    {0, 9, HSV_RED}
);
const rgblight_segment_t PROGMEM _NAV_layer[] = RGBLIGHT_LAYER_SEGMENTS(
    {0, 9, HSV_RED}
);
const rgblight_segment_t* const PROGMEM _rgb_layers[] = RGBLIGHT_LAYERS_LIST(
    _QWERTY_layer, 
    _NUMBER_layer, 
    _SYMBOL_layer,
    _NAV_layer
);

void keyboard_post_init_user(void) {
    // Enable the LED layers
    rgblight_layers = _rgb_layers;
}

layer_state_t layer_state_set_kb(layer_state_t state) {
    print("state: ");
    print(get_highest_layer(state));
    switch (get_highest_layer(state))
    {
    case _QWERTY:
        // rgblight_set_layer_state(0, 1);
        rgblight_setrgb(0, 0, 255);
        break;
    case _NUMBER:
        // rgblight_set_layer_state(1, 1);
        rgblight_setrgb(0, 255, 255);
        break;
    case _SYMBOL:
        // rgblight_set_layer_state(2, 1);
        rgblight_setrgb(0, 255, 0);
        break;
    case _NAV:
        // rgblight_set_layer_state(3, 1);
        rgblight_setrgb(255, 0, 0);
        break;
    }
    return state;
}

layer_state_t default_layer_state_set_kb(layer_state_t state) {
    rgblight_set_layer_state(0, 1);
    return state;
}